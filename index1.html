<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // GLOBAL ARRAY METHODS
    Array.isArray([]); // true  Проверка на то является ли передаваемым обьект
    Array.from(); // Возвращает массив из итерируемого объекта

    // Prototype array methods
    const arr = [];
    const arr1 = new Array();
    const arr2 = new Array(3); // Если один аргумент то это длинна массива
    const arr3 = new Array(1,3,4,5,7,8); // Если больше одного аргумента то это итемы массива

    // Работа с массивом
    arr.length; // Длинна

    arr.push(5); // Добавить в конец массива только один итем, возвращает push текущую длинну массива
    arr.push(1,4,5,6,7); // Добавить в конец массива несколько итемов

    const arr4 = [-1,0].concat([1,2,3,4]); // Возращает новый массив склееный из основного переданого в аргумент // [-1,0,1,2,3,4]
    arr.push(...[1,2,3,4]); // используем spread - аналог concat

    arr.shift(); // Удаляет первое значение массива и возвращает его
    arr.unshift(8); // Добавляет элемент в начало массива и возвращает текущую длинну этого массива.
    arr.unshift(8,2,4,1,3); // Добавляет элементы в начало массива и возвращает текущую длинну этого массива.

    arr.pop(); // Метод удаления последнего элемента из массива, возвращает удаленный элемент

    const arr5 = ["Ваня", "любит", "Касю"];

    const str = arr5.join(" "); // Соединяет элементы массива как единую строку и возвращает её

    const arr6 = new Array(100);

    arr6.fill("Kote"); // Все элементы массива заменяются на переданный аргумент
    arr6.fill("Ivan", 50); // Второй аргумент -  с какой позиции перезаписывать.

    arr5.reverse(); // Выстраивает массив в обратном порядке

    arr5.indexOf(5); // Возвращает индекс элемента либо же -1

    let arr7 = arr5.slice(0, 2); // Первый аргумент индекс с которого копировать массив,
                  // второй аргумент до которого индекса копировать
                  // и возвращает новый массив со скопироваными данными

    let arr8 = arr.splice(0, 2); // Метод вырезающий из массива данные с начального индекса и количество вырезаемых итемов,
                                 // возвращает новый массив с вырезаными элементами

    let arr9 = arr.splice(1, 4, "Vasya", "Kasya", "Vanya"); // Аргументы после количества вырезаемых это итемы которые вставляются по индексу вырезаных

    let a = [];

    arr.forEach(function(item, index) { // Принимает коллбэк и перепирает все элементы массива с этим коллбэком
        if(typeof item === "string") {
            console.log(item, index);
            a.push(item);
        }
    });


    /*
    function forEach(array, callback){
        if(!Array.isArray(array)){
            return console.log("First argument must be an array");
        }
        if(typeof callback !== 'function') {
            return console.log("Second argument must be a function");
        }

        for(let i = 0; i < array.length; i++) {
            let item = array[i];
            callback(item, i);
        }

    }

    forEach([1, 2, 3, 4, 5, 6, 7], (item, index) => {
        if(typeof item === "string") {
            console.log(item, index);
        }
    });
*/

    const filteredArr = arr.filter(function (item) { // Принимает коллбэк. Возвращает массив с отфильтроваными элементами
        if (item % 2 === 0) {
            return true;
        }

        return false;
    });

    /*// polyfill
    function filter(array, callback){ // Возвращает массив с отфильтроваными элементами
        if(!Array.isArray(array)){
            return console.log("First argument must be an array");
        }
        if(typeof callback !== 'function') {
            return console.log("Second argument must be a function");
        }

        const result = [];

        for(let i = 0; i < array.length; i++) {
            let item = array[i];
            const bool = callback(item, i);

            if(bool === true) {
                result.push(item);
            }
        }

        return result;
    }*/

    const mapped = arr.map(function(item, index) { // Возвращает новый массив с обработанными данными
        return item + 2;                           // В коллбэке возвращать нужно всегда ()
    });

    const result = arr.reduce(function(memo, item, index, arr) { // Принимает коллбэк и начальное аккумулируемое значение.Возвращает аккумулируемое значение memo
        return memo + item;
    }, 0);

    arr.sort(function(a, b) { // Сортировка возвращает старый массив с сортироваными элементами (Quicksort)
        if( a < b ) {
            return 1;
        } else if ( a > b ) {
            return -1;
        } else {
            return 0;
        }
    });

    arr.every(function(item, i) { // Возвращает Boolean  в зависимости от того являются ли все элементы под проверкой true.
        if(typeof item === "number") {
            return true;
        }

        return false;
    });

    arr.some(function(item, i) { // Возвращает true если хотябы один элемент соответствует проверке в коллбэке
        if(typeof item === "number") {
            return true;
        }

        return false;
    });

    //  Set -> Array

    const set = new Set([1,2,2,3]);

    set.add(4);
    set.get(0); //  Returns value by index
    set.has(3); // Boolean
    set.delete(0);

    set.clear(); //  Очищает весь сет

    set.forEach(function(item, i) {
        console.log(item);
    });


    // Map -> Object

    const map = new Map([[ "value", 1 ], ["key", 'value']]);

    map.set("key1", "value2");
    map.has("key1");
    map.get("key1");
    map.delete("key1");
    map.clear();

    map.forEach(function(item, key) {
        console.log(item, key);
    });


</script>
</body>
</html>